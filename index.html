<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Jeu HTML – Dimensions Adaptatives & Vitesse de Descente Dynamique</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #000;
    }
    canvas {
      display: block;
      background-color: #000;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    // Variables de dimensions qui seront calculées dynamiquement
    let brickOffsetLeft, brickOffsetRight, brickPadding;
    let brickColumnCount, brickWidth, brickHeight, brickStep, brickRowInterval, baseBrickVelocity;

    // Mise à jour des dimensions en fonction de la taille de l'écran
    function updateDimensions() {
      // Pour que les briques remplissent toute la largeur, on définit des marges et un padding
      brickOffsetLeft = 30;
      brickOffsetRight = 30;
      brickPadding = 10;
      // Choix du nombre de colonnes en fonction de la largeur du canvas
      if (canvas.width < 600) {
        brickColumnCount = 4;
      } else {
        brickColumnCount = 8;
      }
      // Calcul de la largeur de chaque brique pour occuper tout l'espace
      brickWidth = (canvas.width - brickOffsetLeft - brickOffsetRight - (brickColumnCount - 1) * brickPadding) / brickColumnCount;
      // On conserve un ratio 3:1 pour la largeur/hauteur (comme 60:20 dans la version initiale)
      brickHeight = brickWidth / 3;
      // Le "cran" de déplacement correspond à la hauteur de la brique + le padding vertical
      brickStep = brickHeight + brickPadding;
      // Intervalle de temps (ms) pour qu'un cran complet soit parcouru (base = 2000 ms)
      brickRowInterval = 2000;
      // Vitesse de descente de base (en pixels/ms)
      baseBrickVelocity = brickStep / brickRowInterval;
      
      // Taille du vaisseau : on l'adapte à la largeur de l'écran
      spaceship.width = Math.max(canvas.width / 20, 20);
      spaceship.height = spaceship.width;
    }

    // Ajustement du canvas et recalcul des dimensions
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      spaceship.y = canvas.height - 30;
      updateDimensions();
      recalcBricksPositions();
    }
    window.addEventListener("resize", resizeCanvas);

    // Vaisseau (triangle)
    const spaceship = {
      x: 0, // initialisé via resizeCanvas()
      y: 0,
      width: 0,
      height: 0,
    };

    // Variables globales
    let score = 0;
    let gameOver = false;
    let lastTime = performance.now();

    // Paramètres de tir
    const baseMissileInterval = 500; // en ms
    const minMissileInterval = 100;  // cadence maximale (5 fois plus rapide)
    let rapidfireCount = 0;          // cumul des power‑up rapidfire
    let missileIntervalTime = baseMissileInterval;
    let missileIntervalID = setInterval(fireMissile, missileIntervalTime);

    function updateMissileInterval() {
      // On plafonne le cumul à 5
      let count = Math.min(rapidfireCount, 5);
      // Formule logarithmique : quand count=5, l'intervalle devient minMissileInterval
      missileIntervalTime = baseMissileInterval - (baseMissileInterval - minMissileInterval) * (Math.log(count + 1) / Math.log(6));
      clearInterval(missileIntervalID);
      missileIntervalID = setInterval(fireMissile, missileIntervalTime);
    }

    // Pour les gros missiles
    let bigMissileActive = false;
    let bigMissileIntervalID = null;

    // Vitesses (en pixels par seconde)
    const missileSpeed = 400;
    const bigMissileSpeed = 400;
    
    // Tableaux d'objets du jeu
    let missiles = [];    // missiles normaux
    let bigMissiles = [];  // gros missiles
    let powerUps = [];    // power‑ups qui tombent

    // INITIALISATION DES BRIQUES
    // On initialise l'array après avoir défini les dimensions
    let bricks = [];
    function initBricks() {
      bricks = [];
      for (let c = 0; c < brickColumnCount; c++) {
        bricks[c] = [];
        // On part d'un nombre initial de lignes (ici 3)
        for (let r = 0; r < 3; r++) {
          const brickX = brickOffsetLeft + c * (brickWidth + brickPadding);
          const brickY = 30 + r * (brickHeight + brickPadding); // brickOffsetTop fixé à 30
          bricks[c].push({ x: brickX, y: brickY, status: 1 });
        }
      }
    }

    // Permet de recalculer les positions des briques en cas de redimensionnement
    function recalcBricksPositions() {
      for (let c = 0; c < bricks.length; c++) {
        for (let j = 0; j < bricks[c].length; j++) {
          bricks[c][j].x = brickOffsetLeft + c * (brickWidth + brickPadding);
          // La position verticale est déterminée par son index j
          bricks[c][j].y = 30 + j * (brickHeight + brickPadding);
        }
      }
    }

    // On effectue la première initialisation
    resizeCanvas();
    initBricks();

    // Fonction de tir d'un missile normal
    function fireMissile() {
      if (gameOver) return;
      const missileX = spaceship.x;
      const missileY = spaceship.y - spaceship.height;
      missiles.push({ x: missileX, y: missileY, width: 4, height: 10, speed: missileSpeed });
    }

    // Fonction de tir d'un gros missile
    function fireBigMissile() {
      if (gameOver) return;
      const missileX = spaceship.x;
      const missileY = spaceship.y - spaceship.height;
      bigMissiles.push({ x: missileX, y: missileY, width: 8, height: 20, speed: bigMissileSpeed });
    }

    // Active le tir automatique des gros missiles toutes les 5 s
    function activateBigMissile() {
      if (!bigMissileActive) {
        bigMissileActive = true;
        bigMissileIntervalID = setInterval(fireBigMissile, 5000);
      }
    }

    // Dessiner le vaisseau (triangle)
    function drawSpaceship() {
      ctx.beginPath();
      ctx.moveTo(spaceship.x, spaceship.y - spaceship.height);
      ctx.lineTo(spaceship.x - spaceship.width, spaceship.y);
      ctx.lineTo(spaceship.x + spaceship.width, spaceship.y);
      ctx.closePath();
      ctx.fillStyle = "#00FF00";
      ctx.fill();
    }

    // Dessiner les missiles normaux
    function drawMissiles() {
      ctx.fillStyle = "#FF0000";
      missiles.forEach(m => {
        ctx.fillRect(m.x - m.width / 2, m.y, m.width, m.height);
      });
    }

    // Dessiner les gros missiles
    function drawBigMissiles() {
      ctx.fillStyle = "#FFA500";
      bigMissiles.forEach(m => {
        ctx.fillRect(m.x - m.width / 2, m.y, m.width, m.height);
      });
    }

    // Dessiner les briques (on ajoute brickAccumulated pour le smooth)
    function drawBricks() {
      for (let c = 0; c < brickColumnCount; c++) {
        bricks[c].forEach(b => {
          if (b.status === 1) {
            ctx.beginPath();
            ctx.rect(b.x, b.y + brickAccumulated, brickWidth, brickHeight);
            ctx.fillStyle = "#0095DD";
            ctx.fill();
            ctx.closePath();
          }
        });
      }
    }

    // Dessiner les power‑ups
    function drawPowerUps() {
      powerUps.forEach(p => {
        ctx.beginPath();
        ctx.rect(p.x - p.width / 2, p.y - p.height / 2, p.width, p.height);
        ctx.fillStyle = (p.type === "rapidfire") ? "#FFFF00" : "#FF00FF";
        ctx.fill();
        ctx.closePath();
      });
    }

    // Mise à jour des missiles (dt en ms)
    function updateMissiles(dt) {
      for (let i = 0; i < missiles.length; i++) {
        missiles[i].y -= missiles[i].speed * dt / 1000;
        if (missiles[i].y < 0) {
          missiles.splice(i, 1);
          i--;
        }
      }
    }

    function updateBigMissiles(dt) {
      for (let i = 0; i < bigMissiles.length; i++) {
        bigMissiles[i].y -= bigMissiles[i].speed * dt / 1000;
        if (bigMissiles[i].y < 0) {
          bigMissiles.splice(i, 1);
          i--;
        }
      }
    }

    function updatePowerUps(dt) {
      for (let i = 0; i < powerUps.length; i++) {
        powerUps[i].y += powerUps[i].speed * dt / 1000;
        if (powerUps[i].y - powerUps[i].height / 2 > canvas.height) {
          powerUps.splice(i, 1);
          i--;
        }
      }
    }

    // Collision entre missiles normaux et briques
    function collisionDetectionMissiles() {
      for (let i = 0; i < missiles.length; i++) {
        let m = missiles[i];
        outer: for (let c = 0; c < brickColumnCount; c++) {
          for (let j = 0; j < bricks[c].length; j++) {
            let b = bricks[c][j];
            if (b.status === 1) {
              if (m.x > b.x && m.x < b.x + brickWidth &&
                  m.y < b.y + brickAccumulated + brickHeight &&
                  m.y + m.height > b.y + brickAccumulated) {
                b.status = 0;
                score += 10;
                missiles.splice(i, 1);
                i--;
                // 20% de chance de dropper un power‑up
                if (Math.random() < 0.2) {
                  let type = Math.random() < 0.5 ? "rapidfire" : "bigmissile";
                  powerUps.push({
                    x: b.x + brickWidth / 2,
                    y: b.y + brickAccumulated + brickHeight / 2,
                    type: type,
                    width: 20,
                    height: 20,
                    speed: 100
                  });
                }
                break outer;
              }
            }
          }
        }
      }
    }

    // Collision entre gros missiles et briques (avec explosion)
    function collisionDetectionBigMissiles() {
      for (let i = 0; i < bigMissiles.length; i++) {
        let m = bigMissiles[i];
        outer: for (let c = 0; c < brickColumnCount; c++) {
          for (let j = 0; j < bricks[c].length; j++) {
            let b = bricks[c][j];
            if (b.status === 1) {
              if (m.x > b.x && m.x < b.x + brickWidth &&
                  m.y < b.y + brickAccumulated + brickHeight &&
                  m.y + m.height > b.y + brickAccumulated) {
                explodeBrick(b);
                bigMissiles.splice(i, 1);
                i--;
                break outer;
              }
            }
          }
        }
      }
    }

    // Explosion : détruit la brique touchée et les briques adjacentes
    function explodeBrick(hitBrick) {
      const centerX = hitBrick.x + brickWidth / 2;
      const centerY = hitBrick.y + brickAccumulated + brickHeight / 2;
      for (let c = 0; c < brickColumnCount; c++) {
        for (let j = 0; j < bricks[c].length; j++) {
          let b = bricks[c][j];
          if (b.status === 1) {
            const bCenterX = b.x + brickWidth / 2;
            const bCenterY = b.y + brickAccumulated + brickHeight / 2;
            if (Math.abs(bCenterX - centerX) <= brickWidth + brickPadding &&
                Math.abs(bCenterY - centerY) <= brickHeight + brickPadding) {
              b.status = 0;
              score += 10;
            }
          }
        }
      }
    }

    // Collision entre power‑ups et le vaisseau
    function collisionDetectionPowerUps() {
      for (let i = 0; i < powerUps.length; i++) {
        let p = powerUps[i];
        if (
          p.x - p.width / 2 < spaceship.x + spaceship.width &&
          p.x + p.width / 2 > spaceship.x - spaceship.width &&
          p.y - p.height / 2 < spaceship.y &&
          p.y + p.height / 2 > spaceship.y - spaceship.height
        ) {
          if (p.type === "rapidfire") {
            rapidfireCount++;
            updateMissileInterval();
          } else if (p.type === "bigmissile") {
            activateBigMissile();
          }
          powerUps.splice(i, 1);
          i--;
        }
      }
    }

    // Pour l'animation smooth de la descente des briques
    let brickAccumulated = 0;
    function updateBricks(dt) {
      // La vitesse de descente augmente linéairement avec le score.
      // Ici, on ajoute 20 % de vitesse supplémentaire tous les 500 points.
      let dynamicBrickVelocity = baseBrickVelocity * (1 + (score / 500) * 0.2);
      brickAccumulated += dynamicBrickVelocity * dt;
      if (brickAccumulated >= brickStep) {
        for (let c = 0; c < brickColumnCount; c++) {
          bricks[c].forEach(b => {
            b.y += brickStep;
          });
          const newBrick = { x: brickOffsetLeft + c * (brickWidth + brickPadding), y: 30, status: 1 };
          bricks[c].unshift(newBrick);
        }
        brickAccumulated -= brickStep;
      }
    }

    // Vérification du Game Over : si une brique atteint le niveau du vaisseau
    function checkGameOver() {
      for (let c = 0; c < brickColumnCount; c++) {
        for (let j = 0; j < bricks[c].length; j++) {
          let b = bricks[c][j];
          if (b.status === 1 && (b.y + brickAccumulated + brickHeight) >= spaceship.y) {
            gameOver = true;
            clearInterval(missileIntervalID);
            if (bigMissileIntervalID) clearInterval(bigMissileIntervalID);
            return;
          }
        }
      }
    }

    // Affichage du score et du message Game Over
    function drawScore() {
      ctx.fillStyle = "#FFF";
      ctx.font = "20px Arial";
      ctx.fillText("Score: " + score, 10, 30);
      if (gameOver) {
        ctx.font = "50px Arial";
        ctx.fillStyle = "#FF0000";
        ctx.fillText("PERDU", canvas.width / 2 - 100, canvas.height / 2);
      }
    }

    // Boucle principale avec dt
    function draw() {
      const currentTime = performance.now();
      const dt = currentTime - lastTime;
      lastTime = currentTime;
      
      if (!gameOver) {
        updateBricks(dt);
        updateMissiles(dt);
        updateBigMissiles(dt);
        updatePowerUps(dt);
        collisionDetectionMissiles();
        collisionDetectionBigMissiles();
        collisionDetectionPowerUps();
        checkGameOver();
      }
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawBricks();
      drawSpaceship();
      drawMissiles();
      drawBigMissiles();
      drawPowerUps();
      drawScore();
      
      if (!gameOver) {
        requestAnimationFrame(draw);
      }
    }
    draw();

    // Gestion du déplacement par toucher (et souris pour test PC)
    canvas.addEventListener("touchmove", function(e) {
      e.preventDefault();
      const touch = e.touches[0];
      spaceship.x = touch.clientX;
      if (spaceship.x < spaceship.width) spaceship.x = spaceship.width;
      if (spaceship.x > canvas.width - spaceship.width) spaceship.x = canvas.width - spaceship.width;
    }, { passive: false });

    canvas.addEventListener("mousemove", function(e) {
      spaceship.x = e.clientX;
      if (spaceship.x < spaceship.width) spaceship.x = spaceship.width;
      if (spaceship.x > canvas.width - spaceship.width) spaceship.x = canvas.width - spaceship.width;
    });
  </script>
</body>
</html>
